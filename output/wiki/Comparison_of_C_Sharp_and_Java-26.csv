Java,C#
<source lang=Java> // initialize the engine var factory = new ScriptEngineManager(); var invocable = (Invocable) factory.getEngineByName("jruby"); var fr = new FileReader("Deepthought.rb"); engine.eval(fr); </source>,<source lang=CSharp> // initialize the engine var runtime = ScriptRuntime.CreateFromConfiguration(); dynamic globals = runtime.Globals; runtime.ExecuteFile("Deepthought.rb"); </source>
<source lang=Java> // create a new instance of "Deepthought" calculator var calcClass = engine.eval("Deepthought"); var calc = invocable.invokeMethod(calcClass  "new"); // set calculator input values invocable.invokeMethod(calc  "a="  6); invocable.invokeMethod(calc  "b="  7); // calculate the result var answer = invocable.invokeMethod(calc  "Calculate"); </source>,<source lang=CSharp> // create a new instance of "Deepthought" calculator var calc = globals.Deepthought.@new(); // set calculator input values calc.a = 6; calc.b = 7; // calculate the result var answer = calc.Calculate(); </source>
Notes for the Java implementation: Ruby accessors names are generated from the attribute name with a <kbd>=</kbd> suffix. When assigning values  Java developers must use the Ruby accessor method name. Dynamic objects from a foreign language are not first-class objects in that they must be manipulated through an API.,Notes for the C# implementation: Objects returned from properties or methods of <kbd>dynamic</kbd> objects are themselves of <kbd>dynamic</kbd> type. When type inference (the <kbd>var</kbd> keyword) is used  the variables calc and answer are inferred dynamic/late-bound. Dynamic  late-bounds objects are first-class citizens that can be manipulated using C# syntax even though they have been created by an external language. <kbd>new</kbd> is a reserved word. The <kbd>@</kbd> prefix allows keywords to be used as identifiers.
